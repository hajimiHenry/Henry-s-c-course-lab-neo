# 25-13-6 位置调整：二维数组传参与指针访问总结（合并讲义）

对应代码：`Henry-s-c-course-lab-neo/25-13/25-13-6codex.c`

本讲义把我们讨论过的关键点（二维数组传参、数组退化、指针访问写法、swap 为啥要传地址、四角最小值如何不重复）和原有两份讲义内容合并整理成一份。

---

## 1. 题目要求（做什么）

输入一个 `5×5` 整数矩阵，调整后输出：

1. 把**最大值**放到中心 `(2,2)`
2. 把**4 个最小值**按从小到大依次放到四角：
   - `(0,0)` 最小
   - `(0,4)` 第二小
   - `(4,0)` 第三小
   - `(4,4)` 第四小
3. 题目希望你理解“指针方式”访问二维数组（但你写代码时也可以先用下标写清楚，再翻译成指针写法）

---

## 2. 二维数组怎么传参：`int (*a)[5]` 到底是什么

在函数里写：

```c
void adjust_codex(int (*a)[5]);
```

读法：`a` 是一个指针，指向“长度为 5 的 int 数组”（也就是指向**一整行**）。

### 2.1 调用时到底传进来什么？

在 `main` 里有二维数组：

```c
int a[5][5];
adjust_codex(a);
```

这里的 `a` 在表达式里会发生“数组退化”（array-to-pointer conversion）：

- `a` 退化成指向首元素的指针
- 对二维数组来说，“首元素”是第 0 行 `a[0]`（类型是 `int[5]`）
- 所以传进去的是 `&a[0]`，类型正好是 `int (*)[5]`

一个非常重要的对比：

- `&a[0]` 的类型：`int (*)[5]`（行指针，+1 跳过一整行 5 个 int）
- `&a[0][0]` 的类型：`int *`（元素指针，+1 只跳过 1 个 int）

它们的“数值地址”通常一样（都在这块内存起点），但**类型不同 → 指针加法的步长不同**，这就是为什么形参必须写对。

### 2.2 为什么第二维要写死成 5？

因为编译器要算 `a[i][j]` 的地址，需要知道每行有多少个元素（步长）。

对固定 `5×5` 来说，写成 `int (*a)[5]` 是最简单最清晰的。

---

## 3. `*(*(a+i)+j)` 怎么读？为什么等价 `a[i][j]`

从里往外读：

1. `a + i`：指向第 `i` 行（类型 `int (*)[5]`）
2. `*(a + i)`：第 `i` 行这个数组（类型 `int[5]`，在表达式里会退化成 `&a[i][0]`）
3. `*(a + i) + j`：第 `i` 行第 `j` 列的地址（类型 `int*`），等价 `&a[i][j]`
4. `*(*(a + i) + j)`：取出这个地址里的值，等价 `a[i][j]`

你可以直接记两条等价式：

```c
a[i][j]  == *(*(a + i) + j)
&a[i][j] ==  *(a + i) + j
```

---

## 4. 内存里地址是怎么排列的（为什么“行指针”能工作）

`int a[5][5]` 在内存里是**连续**的 25 个 `int`，按行依次排：

- 第 0 行的 5 个 int 挨在一起
- 第 1 行紧跟在第 0 行后面
- …

如果 `int` 占 4 字节，那么：

```text
&a[i][j] = &a[0][0] + (i*5 + j) * 4
```

因为 `a` 是“指向一行”的指针，所以 `a+i` 一次跨过 5 个 int（也就是一行），再在行内 `+j` 才能到具体列。

---

## 5. 为什么 swap 要传指针（地址）？值传递为什么不行？

C 里函数参数默认是**值传递**：传进去的是“拷贝”。

所以：

```c
swap(a[i][j], a[2][2]);   // 传的是两个数值的拷贝
```

在 `swap(int x, int y)` 里交换，只会交换 `x/y` 这两个局部变量，**数组不变**。

要真正改数组里的元素，你必须把“位置（地址）”传进去：

```c
swap(&a[i][j], &a[2][2]);
```

然后在 `swap(int *p, int *q)` 里用 `*p` / `*q` 修改原位置的值。

---

## 6. 核心算法：如何“放到指定位置”但不把已经放好的再弄乱

思路就是：**找极值的“位置”（地址/下标）→ 交换到目标位置**。

### 6.1 第一步：最大值放中心

扫描 25 个元素，记下最大值位置（例如用 `pmax` 指针记录地址），最后：

- `swap(pmax, &a[2][2]);`

### 6.2 第二步：四个最小值放四角（且不重复）

关键是“不能重复选到已经放好的格子”，否则你可能把中心最大值或已放好的角又交换走。

通用做法：

1. 用一个数组 `fixed[]` 记录“已经固定不许再动”的位置（存的是元素地址 `int*`）
2. 每次找当前最小值时，遇到在 `fixed[]` 里的位置就跳过
3. 找到最小值 `pmin` 后，与当前目标角 `target` 交换
4. 把 `target` 加入 `fixed[]`

目标角顺序就是：`(0,0) → (0,4) → (4,0) → (4,4)`。

---

## 7. 常见易错点（你写自己版本时重点检查）

1. 形参类型写错：`int *(a)[5]` 不是二维数组参数（会退化成 `int**`），正确是 `int (*a)[5]` 或 `int a[][5]`
2. 找最大值/最小值时忘了同步更新“当前极值变量”或“位置”
3. 用 `swap(int a, int b)` 交换数组元素（不生效），要用 `swap(int *a, int *b)` 或直接三句交换
4. 判断“是否在中心”不要比数值相等（可能值相同但位置不同），应比下标或指针地址

---

## 8. 编译运行（Windows / PowerShell）

在目录 `Henry-s-c-course-lab-neo/25-13`：

```powershell
gcc -std=c11 -Wall -Wextra -O2 25-13-6codex.c -o 25-13-6codex.exe
.\25-13-6codex.exe
```

