# 25-13-6 位置调整（指针版讲义）

对应代码：`Henry-s-c-course-lab-neo/25-13/25-13-6codex.c`

## 1. 题目要求

输入一个 `5×5` 的整数矩阵（共 5 行，每行 5 个数），调整后输出仍为 5 行（每个元素用 `%3d` 输出）：

- 把 **最大值** 放到中心位置 `(2,2)`。
- 把 **4 个最小值** 放到四个角，并按从小到大依次放：
  - `(0,0)` 最小
  - `(0,4)` 第二小
  - `(4,0)` 第三小
  - `(4,4)` 第四小
- 要求用“指针方式”实现。

## 2. 关键知识点：二维数组参数与指针访问

二维数组 `int a[5][5]` 传参常用写法：

```c
void adjust_codex(int (*a)[5]);
```

含义：`a` 指向“长度为 5 的整型数组”（一行）。

指针访问二维数组元素（本题要求的风格）：

- 第 `i` 行第 `j` 列元素地址：`*(a + i) + j`
- 第 `i` 行第 `j` 列元素值：`*(*(a + i) + j)`

对比下标写法：

- `a[i][j]` 等价于 `*(*(a + i) + j)`
- `&a[i][j]` 等价于 `*(a + i) + j`

## 3. 核心思路：扫描 + 交换（swap）

“把某个元素放到指定位置”最直接的方法是 **交换两个位置的值**。

代码里用 `swap_int_codex(int *a, int *b)` 完成交换（传入两个元素的地址）。

### 3.1 第一步：最大值放中心

1. 扫描 25 个元素，找到最大值所在地址 `pmax`。
2. 与中心地址 `&a[2][2]` 做一次交换：最大值就到了中心。

### 3.2 第二步：四个最小值放四角（按顺序）

为了避免“把已经放好的中心/角又换走”，代码采用“固定位置”思想：

- 用 `fixed[]` 记录已经固定的元素地址（先固定中心，再依次固定每个角）。
- 选最小值时跳过这些固定地址（`is_fixed_codex` 用来判断是否固定）。

四个角的目标顺序是：

1. `(0,0)`
2. `(0,4)`
3. `(4,0)`
4. `(4,4)`

对每个角重复：

1. 在“未固定”的元素里扫描出当前最小值 `pmin`
2. 交换 `pmin` 与该角的地址
3. 把该角地址加入 `fixed[]`

这样能保证四个角依次放的是第 1/2/3/4 小，同时不会破坏中心最大值和已放好的角。

## 4. 代码结构导读（建议你对照阅读）

文件：`Henry-s-c-course-lab-neo/25-13/25-13-6codex.c`

- `swap_int_codex`：交换两个整数位置
- `is_fixed_codex`：判断某地址是否已固定
- `adjust_codex`：按题意调整矩阵（最大值到中心、四个最小到四角）
- `main`：读入、调用、输出（`%3d`）

## 5. 编译运行（Windows / PowerShell）

在目录 `Henry-s-c-course-lab-neo/25-13`：

```powershell
gcc -std=c11 -Wall -Wextra -O2 25-13-6codex.c -o 25-13-6codex.exe
.\25-13-6codex.exe
```

## 6. 自检练习（建议你做）

1. 把四个角改成放“4 个最大值”，中心放“最小值”（练习“找极值+交换”的改写）。
2. 把 `is_fixed_codex` 的“地址固定”改为“坐标固定”（用 `(i,j)` 判断），体会两种思路差异。
