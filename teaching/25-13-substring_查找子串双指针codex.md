# 25-13：查找子串（双循环 + 双指针）（讲义）

目标：实现

```c
char *search(char *s, char *t);
```

含义：
- 在字符串 `s` 中寻找子串 `t` 第一次出现的位置
- 找到：返回“匹配起点”的地址（`char*`）
- 找不到：返回 `NULL`

主函数里常见写法：
- `pos - s` 是“指针差”，得到从 `s[0]` 开始的下标（0-based）
- 找不到输出 `-1`

---

## 这段代码里每个指针的角色

以你文件里的实现为例：

```c
for (p = s; *p != '\0'; p++) {
    ps = p;
    pt = t;
    while (*ps != '\0' && *pt != '\0' && *ps == *pt) {
        ps++;
        pt++;
    }
    if (*pt == '\0') return p;
}
return NULL;
```

角色分工（非常重要）：
- `p`：外层循环的“候选起点”，依次尝试 `s` 的每个位置
- `ps`：从当前候选起点 `p` 出发，在 `s` 上向右滑动的“游标”
- `pt`：在 `t` 上向右滑动的“游标”（每次新起点都必须从 `t[0]` 开始）

为什么要 `ps = p; pt = t;`？
- 内层比较会不断 `++`，所以需要“游标”去移动
- 但 `p` 不能被破坏（成功时要 `return p`，失败后外层还要 `p++`）
- `t` 也不能被破坏（每次新起点都要从 `t` 的开头重新比较）

---

## 双循环在“做什么”

可以把它理解成两层含义：

### 1）外层：枚举所有可能起点
`p` 从 `s[0]` 走到 `'\0'` 之前的每一个位置：`p = s + 0, s + 1, s + 2, ...`

每一个 `p` 都在问同一句话：
> “如果从这里开始，`t` 能不能完整匹配上？”

### 2）内层：从这个起点开始逐字符比对
`ps` 从 `p` 开始向右走；`pt` 从 `t` 开始向右走。

内层 `while` 的继续条件是：
- `ps` 没到 `s` 末尾
- `pt` 没到 `t` 末尾
- 当前字符相等

一旦跳出 `while`，只可能是三种原因之一：
1. `*pt == '\0'`：`t` 已经完全匹配完了 → 成功，返回 `p`
2. `*ps == '\0'`：`s` 先结束了 → 失败，换下一个起点
3. `*ps != *pt`：遇到字符不相等 → 失败，换下一个起点

---

## 空子串（边界情况）

很多题默认：空串在任何串的开头都算“匹配成功”，因此：

```c
if (t == NULL || *t == '\0') return s;
```

如果你课程/平台对“空子串”有不同要求，再按要求调整即可。

---

## 想“看见”指针怎么走

直接看输出最直观：`teaching/25-13-substring/trace_search.c` 提供了一个带打印的版本，
能把每次尝试的起点、每次字符比较、哪里失败/哪里成功都打印出来。
