# 13 题教训总结：回文判断与最大串

先生，你这题的代码已经基本正确了。这里把这题最值得记住的“坑”和“固定做法”整理成一份小讲义，方便你以后做同类题时直接套用。

---

## 1. 题目要做的两件事

一组数据里通常要同时完成两类任务：

1) **判断整组是否满足某条件**  
本题是：这一组的 **N 个字符串是否都为回文串**。

2) **在整组里找一个“最值”**  
本题是：这一组里 **字典序最大的字符串**。

这两件事都必须在“读完整组输入”的过程中完成，否则容易出现输出次数不对或最大值跨组污染。

---

## 2. 回文判断（字符串两端向中间）

**核心思想**：用两个下标 `first` / `last`，分别指向首尾；每次比较 `arr[first]` 与 `arr[last]`，相等就向中间收缩。

要点：

- 一旦发现不等，立刻返回“不是回文”。
- 循环条件可以用 `first < last`，或用 `p < len/2` 都可以。

---

## 3. “整组都满足” 的标志位写法（all 模式）

这题最容易写错的点，是把 “都满足” 写成了 “出现过一次满足”。

### 正确含义
- 题目要的是：**全部都是回文 → YES**  
也就是逻辑上的“AND”（全真才真）。

### 固定写法（推荐记住）

- 进入每组时：`int all = 1;`（先假设全都满足）
- 读到每个字符串时：
  - 如果发现一个不满足：`all = 0;`
  - **不要**再把 `all` 改回 1

这样就保证了：只要有一个不是回文，这组最终一定是 `NO`。

---

## 4. 找最大字符串：第一次初始化 + 之后比较更新

本题“最大串”用的是 `strcmp`（字典序比较）。

固定写法：

- 读到第 1 个串（`j==0`）时：把它当作初始最大值 `maxstr`
- 之后每读一个串：如果 `strcmp(arr, maxstr) > 0`，就更新 `maxstr`

这样可以避免 `maxstr` 未初始化就比较的问题。

---

## 5. 典型坑点清单（这题你遇到过的）

### 5.1 把比较写成赋值

- 错误：`if (j = 0)`  
  这会把 `j` 改成 0，条件判断也会失真，循环行为被破坏。
- 正确：`if (j == 0)`

### 5.2 传参 `arr` 和 `&arr` 的区别

- `char arr[50];` 在函数调用中写 `arr`，会“退化”为 `char*`（指向首元素）
- `&arr` 的类型是“数组的地址”，不是同一个概念

本题应传：`checkequl(arr)`。

### 5.3 输出位置不对

题目要求：**每组输出一行**。  
所以输出必须放在“读完这一组 N 个字符串之后”，而不是放在读每个字符串的循环里。

### 5.4 最大串跨组污染

如果 `maxstr` 放在外层循环外，下一组可能会继承上一组的最大值。  
本题你的新版本把 `maxstr` 放进每组里初始化，这是正确的习惯。

### 5.5 输入越界（稳妥写法）

- 建议写：`scanf("%49s", arr);`
- 原因：`arr` 长度 50，需要留一个 `'\0'`，这样最多读 49 个字符更安全

---

## 6. 一份可直接套用的“组处理模板”

做“每组：判全满足 + 找最值”的题，可以按这个模板写：

1) 读组规模 `num`
2) 初始化：
   - `all = 1`
   - `maxstr` 在 `j==0` 时赋初值
3) 循环读 `num` 次：
   - 用条件失败时把 `all` 置 0
   - 用比较更新 `maxstr`
4) 循环结束后输出：`YES/NO` + `maxstr`

---

## 7. 建议你保留的好习惯

- 每组数据的状态变量（例如 `found/all`、`maxstr`）放在外层循环内部初始化
- 输出只在处理完一组之后进行一次
- 写条件时优先使用“先假设成立，再发现失败就推翻”的写法（更不容易漏情况）

