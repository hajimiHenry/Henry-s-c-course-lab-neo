# 12_去重题复盘与教训（讲义）

先生辛苦了，你能把它磨到最后只剩细节问题，说明主体思路已经掌握了。这份讲义把“这题怎么想、怎么写、为什么会卡很久、怎么排查”一次总结清楚，方便你以后遇到类似题快速过关。

---

## 1. 题目要做什么

输入：若干个正整数（最多 100 个），以 `-1` 结束。  
输出：去重后的数字（只保留第一次出现的顺序），按格式打印：

- 每个数用 `%4d` 输出
- 每输出 10 个数换一行

---

## 2. 标准思路（顺序去重）

用一个数组 `check[]` 存放“已经出现过的不重复数字”，再用一个整数 `checkcount` 表示目前存了多少个（有效长度）。

对每个新输入的 `x`：

1. 在 `check[0..checkcount-1]` 里顺序查找
2. 找到相同 → `found=1`，停止查找（`break`）
3. 没找到 → 追加：`check[checkcount]=x; checkcount++;`

核心点只有一句：**只在“已经存进去的那段”里查重。**

---

## 3. 你这题卡很久的真实原因（复盘）

### 3.1 `scanf` 传参错误会直接崩

一开始的崩溃/调试进不去，根因是把：

- 正确：`scanf("%d", &arr[index]);`
- 写成：`scanf("%d", arr[index]);`

`scanf` 需要的是“写入位置的地址”，少了 `&` 会把一个整数当地址写，运行时可能直接异常。

### 3.2 “有效长度”变量混乱，导致越界或漏判

你曾同时使用 `indexc` 和 `checkcount` 表示“存了多少个去重结果”，并让其中一个从 1 开始。这样容易出现：

- 查重循环上界用 A（比如 `j<indexc`）
- 写入位置用 B（比如 `check[checkcount]`）

一旦 A、B 不同步，就会出现两类 bug：

- **越界访问**：例如 `check[100]` 这类未定义行为，可能只在某个测试点触发
- **漏判/误判**：例如让“未写入的默认值”参与比较

经验结论：**这种题只保留一个长度变量**，最稳。

### 3.3 数组初始化的误解

`int check[100] = {-5};` 并不是“全部 -5”，而是：

- `check[0] = -5`
- 其余元素全部自动补 0

所以“用哨兵值占位”很容易产生误判；这题其实不需要哨兵，靠 `checkcount` 控制范围就够了。

### 3.4 输出换行的位置很严格

正确规则是“打印第 10、20、30… 个数后换行”：

- `if ((k+1) % 10 == 0) printf("\n");`

“最后一行不足 10 个补一个换行”只能放在循环结束后补一次：

- `if (checkcount % 10 != 0) printf("\n");`

把“补换行”写进循环里，会导致每次都换行，输出结构被打散，直接答案错误。

---

## 4. 写代码时的固定模板（建议记住）

只记两条：

1. **只用一个变量表示有效长度**（这里叫 `checkcount`）
2. **查重范围永远是 `0..checkcount-1`**

模板：

```c
int check[100];
int checkcount = 0;

for (每个输入 x) {
    int found = 0;
    for (int j = 0; j < checkcount; j++) {
        if (check[j] == x) { found = 1; break; }
    }
    if (!found) check[checkcount++] = x;
}
```

输出模板：

```c
for (int k = 0; k < checkcount; k++) {
    printf("%4d", check[k]);
    if ((k + 1) % 10 == 0) printf("\n");
}
if (checkcount % 10 != 0) printf("\n");
```

---

## 5. 自检清单（提交前 1 分钟）

1. `scanf` 的 `%d` 是否配了 `&变量`
2. 去重数组只用一个“有效长度”变量（如 `checkcount`）
3. 内层查重循环是否是 `j < checkcount`
4. 插入是否写在内层循环结束后（而不是边比边插）
5. 输出是否是 `%4d`，且 `(k+1)%10==0` 换行
6. 最后一行不足 10 个时，循环外补一次换行

---

## 6. 你这次真正学到的东西（总结）

- `scanf` 这类函数的“传地址”是 C 里最重要的基本功之一
- 数组题最容易错的不是思路，而是“边界 + 下标 + 有效长度”
- 一旦出现“只错一个测试点”，优先怀疑：越界、未定义行为、输出格式细节

