# 程序填空题讲义：数组传参与指针（重点看第 4/5/6 题）

适用题目：`程序填空题题干/程序填空题-题干汇总.md` 的第 4、5、6 题（都是“找最高分”，但函数形参不同）。

---

## 1. 你困惑的点一句话说清

你说“传进去的不都是地址吗？”——**数值上看都是地址，但 C 语言更看重“地址的类型”**：

- `float *p`：只知道指向一个 `float`，**不知道每行有多少列**
- `float (*p)[4]`：指向“含 4 个 float 的一行”，**天然带着列数 4 的信息**

所以你在函数里能不能写 `p[i][j]`，取决于形参到底是哪一种。

---

## 2. 三种形参的“能写什么 / 该怎么传”

下面都用题目里的二维数组变量名 `score[7][4]` 来说。

### 2.1 第 4 题：`void find(float score[7][4], int *hang, int *lie)`

**本质**：形参看起来是二维数组，但在函数参数里会退化为：

- `float (*score)[4]`（指向一行，列数固定 4）

**你在函数里能写：**

- 直接写二维下标：`score[i][j]`

**main 里怎么传：**

- 直接传数组名：`find(score, &maxhang, &maxlie);`

> 注意：这里一般**不传** `&score[0][0]`，因为那是 `float*`，类型不匹配（虽然数值地址可能一样）。

---

### 2.2 第 5 题：`void find(float *score, int *hang, int *lie)`

**本质**：只给了一个 `float*`，它只知道“从某个 float 开始的一串连续内存”，不知道“每行 4 个”。

**你在函数里不能写：**

- 不能写 `score[i][j]`
- 也不能写 `score[*hang][*lie]`（原因：`score[*hang]` 已经是一个 `float` 值了，后面没法再 `[...]`）

**你在函数里应该写（把二维变一维）：**

- 这题列数固定是 4，所以：
  - “第 i 行第 j 列” = `score[i*4 + j]`

举例（只看写法，不管填空分值）：

```c
max = score[0];                 // 等价于 score[0][0]
if (max < score[i*4 + j]) {     // 等价于 max < score[i][j]
    max = score[i*4 + j];
    *hang = i;
    *lie = j;
}
```

**main 里怎么传：**

只要传二维数组的“首元素地址”就行，常见两种写法都对：

- `find(&score[0][0], &maxhang, &maxlie);`
- `find((float*)score, &maxhang, &maxlie);`

---

### 2.3 第 6 题：`void find(float (*p)[4], int *hang, int *lie)`

**本质**：明确告诉编译器“每一行有 4 列”，这就是最标准、最安全的二维数组传参形式之一。

**你在函数里能写：**

- 直接 `p[i][j]`

**main 里怎么传：**

- `find(score, &maxhang, &maxlie);`

---

## 3. 为什么第 5 题要用 `i*4 + j`（用一句话记）

二维数组 `score[7][4]` 在内存里是“按行连续”存的：

`score[0][0], score[0][1], score[0][2], score[0][3], score[1][0], ...`

所以到第 `i` 行要先跳过 `i` 行，每行 4 个元素：先跳 `i*4` 个；再到第 `j` 列：再加 `j`。

> 二维坐标 `(i, j)` 对应一维下标：`i*列数 + j`。这题列数就是 4。

---

## 4. 填空题里这一块最常见的坑（你只要避开就能稳拿分）

1) **列数写错**  
`float (*p)[4]` 里的 `4` 不能乱写，因为它决定了 `p+1` 往后跳多少内存（跳一整行）。

2) **把 `score` 和 `&score[0][0]` 混着传**  
它们地址数值可能一样，但类型不同：
- `score`（退化后）是 `float (*)[4]`
- `&score[0][0]` 是 `float *`
函数要哪种就传哪种。

3) **`scanf` 的 `&`**  
读一个数组元素必须是地址：`scanf("%d", &score[i][j]);`（题干里就这么考空）。

4) **输出编号从 0 还是从 1**  
程序内部下标永远从 0。题目如果要输出从 1 开始，就在赋值/输出时 `+1`（比如 `maxhang=i+1`）。

---

## 5. 一句话对照表（考试时用）

- 形参是 `float score[7][4]` 或 `float (*p)[4]`：函数里用 `score[i][j]` / `p[i][j]`；main 里传 `score`
- 形参是 `float *score`：函数里用 `score[i*4+j]`；main 里传 `&score[0][0]`（或 `(float*)score`）

