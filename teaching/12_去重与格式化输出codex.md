# 12_去重与格式化输出（讲义）

先生你好，先把心放稳：这题不难，难点集中在两个地方——`scanf` 的用法、以及“去重”的循环结构。下面按“能直接写出来并跑通”的方式整理。

## 1. 题目在做什么

输入：若干个正整数（可能重复，最多 100 个），以 `-1` 结束。  
输出：把重复数字去掉（每个数只输出一次），并按要求排版：

- 每个数用 `%4d` 输出（宽度 4，右对齐）
- 每输出 10 个数换一行

## 2. 核心思路（顺序去重）

维护一个数组 `uniq[]`，里面只放“第一次出现”的数字，保持出现顺序不变。

对每个新读入的数字 `x`：

1. 在 `uniq[0..m-1]` 里从头找一遍
2. 如果找到了，说明重复，忽略它
3. 如果没找到，把它追加到 `uniq[m]`，然后 `m++`

因为最多 100 个数，用两层循环查重完全够用，写法也最稳。

## 3. 关键知识点 1：`scanf` 一定要传地址

`scanf("%d", &x);` 里的第二个参数必须是“地址”（标准名：指针 `int*`）。

- `x`：变量的值
- `&x`：变量的地址（`scanf` 需要把读到的结果写到这里）

如果写成 `scanf("%d", x);`，程序会把 `x` 当成地址去写，容易直接崩溃，甚至调试都进不去。

## 4. 关键知识点 2：去重循环的正确结构

去重常见的坑是：在“还没比完”时就插入、或用 `continue` 但没有阻止后续插入。

推荐结构是：

1. 先用 `found` 标记是否出现过
2. 找到就 `break`（结束查找）
3. 内层循环结束后，再决定要不要插入

伪代码：

```c
found = 0;
for (j = 0; j < m; j++) {
    if (uniq[j] == x) { found = 1; break; }
}
if (!found) uniq[m++] = x;
```

## 5. 输出排版：`%4d` + 每 10 个换行

用下标 `i` 控制换行：

- 输出一个数：`printf("%4d", uniq[i]);`
- 若 `(i + 1) % 10 == 0`：输出换行
- 全部输出完后：如果最后一行不足 10 个，补一个换行（更规整）

## 6. 可直接套用的代码框架（最小可运行）

```c
#include <stdio.h>

int main(void) {
    int uniq[100];
    int m = 0;
    int x;

    while (scanf("%d", &x) == 1 && x != -1) {
        int found = 0;
        for (int j = 0; j < m; j++) {
            if (uniq[j] == x) {
                found = 1;
                break;
            }
        }
        if (!found && m < 100) {
            uniq[m++] = x;
        }
    }

    for (int i = 0; i < m; i++) {
        printf("%4d", uniq[i]);
        if ((i + 1) % 10 == 0) putchar('\n');
    }
    if (m % 10 != 0) putchar('\n');
    return 0;
}
```

## 7. 自检清单（3 分钟确认写对）

1. `scanf` 里是否写了 `&x` 或 `&arr[i]`
2. 去重时是否是“先查完再插入”，而不是在内层循环里插入
3. 结束标记 `-1` 是否没有被当作数据输出
4. 输出是否使用了 `%4d`
5. 是否每 10 个换行，最后不足 10 个也有换行

## 8. 常见坑总结（最容易踩的 4 个）

- 把 `scanf("%d", x)` 写成传值而不是传地址 → 运行崩溃
- 用 `continue` 但没有阻止后面插入 → 重复数也会被插入
- 在内层循环里做 `m++`，导致循环边界变化 → 逻辑不稳定
- 忘记按题目格式输出（`%4d`、每 10 个换行）→ 答案格式错误

