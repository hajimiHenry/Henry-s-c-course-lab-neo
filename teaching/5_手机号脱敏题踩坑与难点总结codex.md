# 5_手机号脱敏题踩坑与难点总结codex

这份讲义总结我们做“手机号脱敏 + 末位加密”一路上遇到的典型问题与难点，方便你以后做类似题目直接套用思路。

---

## 1. 题目类型判断：这是“字符串处理题”
**关键判断**：虽然手机号是数字，但题目要做的是：
- 按下标区间替换成 `*`/`#` 等字符
- 输出包含非数字字符

因此必须用字符串（字符数组）处理，而不是用整数类型拆位。

---

## 2. 输入部分最容易错的点

### 2.1 手机号用 `%s` 读，不要用 `%d`
正确：`scanf("%11s", arr[i]);`
- `%11s` 代表最多读 11 个字符，防止溢出
- 存储数组要至少 12：11 位 + `'\0'`

错误模式：
- 用 `%d` 读手机号（会丢位/溢出/无法替换）
- 把 `%s` 写到 `&arr[i][j]` 上（`%s` 会写入一串字符，导致覆盖越界）

### 2.2 读单个字符 `c` 要跳过换行
正确：`scanf(" %c%d%d", &c, &N, &M);`
- `%c` 前的空格用于吃掉上一行残留的 `'\n'`

错误模式：
- `scanf("%c%d%d", ...)` 导致 `c` 读到换行而不是 `*`

---

## 3. 下标与“第几位”要分清
本题明确说明 **下标从 0 开始**：
- 第 1 位是下标 0
- 最后一位是下标 10

所以替换区间 `[N, M]` 的写法是：
```c
for (int i = N; i <= M; i++) s[i] = c;
```
不需要写 `N-1`。

---

## 4. “先替换还是先求和？”——必须先替换
题目求和 `S` 的对象是“最终显示出来的数字字符”。

正确顺序：
1. 先把 `[N,M]` 替换成 `c`
2. 再遍历 0..10 求和（只加数字字符）

错误模式：
- 先求和再替换，得到的是原手机号的数字和，不符合题意

---

## 5. 求和函数最典型的坑：字符和数字的转换
手机号每一位是字符 `'0'..'9'`，要转成数字必须减 `'0'`：
```c
total += s[i] - '0';
```
原因：`'7'` 存的是编码值，不是数字 7。

### 5.1 “带了 * 还怎么求和？”
不会影响：只要你写成“只加数字字符”的判断即可：
```c
if (s[i] >= '0' && s[i] <= '9') total += s[i] - '0';
```
`*`/`#` 不在数字范围内，会自动跳过。

---

## 6. 末位加密逻辑：最容易写反的条件
题意是：
> 最后一位**如果没有被替换**，才做特殊加密处理。

也就是：只有当 `10` 不在 `[N,M]` 时才修改末位：
```c
if (!(N <= 10 && 10 <= M)) {
    // 改 s[10]
}
```

错误模式：
- 条件写反：`if (N <= 10 && 10 <= M)` 时去加密（这时末位已经被替换成 `c` 了）

---

## 7. “k 没初始化”到底是怎么回事（很典型）
你一开始写过这种形式：
```c
k = (arr[p][k] + s) % 10;
```
虽然左边在给 `k` 赋值，但右边先要计算 `arr[p][k]`，此时 `k` 还没值，所以是“未初始化就使用”。

这题根本不需要 `k` 当下标，因为只改末位：用 `arr[p][10]`。

---

## 8. 二维数组传参与“退化”的核心结论（针对你最卡的点）
如果你有：
```c
char arr[n][13];
```

### 8.1 只处理“一行字符串”（最推荐）
```c
int sum_one(const char *s);
sum_one(arr[p]);   // arr[p] 退化为 char*
```

### 8.2 处理“整张表 + 指定行”
```c
int sum_at(const char (*a)[13], int row);
sum_at(arr, p);    // arr 退化为 char (*)[13]
```

### 8.3 为什么 `sum(*arr)` 不对
`*arr` 等价于 `arr[0]`，永远是第 0 行，所以在循环里会算错行。

---

## 9. 素数判断的常见坑
### 9.1 `=` 和 `==` 搞混
错误：`if (n = 2)`（赋值）
正确：`if (n == 2)`（比较）

### 9.2 循环边界
更稳的写法是不使用 `sqrt`：
```c
for (int i = 3; i * i <= n; i += 2) ...
```
避免浮点误差与边界遗漏。

---

## 10. 输出格式
题目要求：每个手机号处理结果占一行。
常用写法：
- `puts(arr[p]);`
- 或 `printf("%s\n", arr[p]);`

---

## 11. 一份“最终套路”（做同类题直接照着写）
对每个字符串 `s`：
1. 替换 `[N,M]` 为 `c`
2. 如果末位没被替换：
   - `S = sum(只加数字字符)`
   - 素数：`newLast = (last + S) % 10`
   - 非素数：`newLast = S % 10`
   - 写回 `s[10] = newLast + '0'`
3. 输出 `s`

---

## 12. 你这次真正进步的点（建议你记下来）
- 明确“字符串题”和“数字题”的分界
- 理解了字符数字 `'7'` 转整数要 `- '0'`
- 理解了二维数组传参为什么要写第二维（退化成“行指针”）
- 能把题意拆成：替换 → 求和 → 条件加密 → 输出

