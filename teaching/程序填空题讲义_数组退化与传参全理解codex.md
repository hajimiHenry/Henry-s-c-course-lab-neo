# 程序填空题讲义：数组退化与传参全理解（你“到底传进去的是啥”）

适用范围：程序填空题里所有“数组/字符串/指针”传参题，尤其是字符串排序（第 9~13 题）和二维数组题（如 `score[7][4]` 相关题）。

---

## 0. 先把一句话刻在脑子里

**在 C 语言里：函数参数位置“不能传数组本体”，你传过去的永远是“地址”。**

更准确地说：

- 如果你在 `main` 里写的是“数组名”，它会在大多数表达式里**退化成指针（地址）**再传进去。
- 但“退化成哪种指针”非常关键：`int*`、`char*`、`float(*)[4]`、`char(*)[20]` 这些**类型不同**，用法也不同。

所以你的困惑“我传的是数组还是地址？”答案是：

> 你写的是数组名，但传进去的是它退化后的指针（地址）；类型信息决定你在函数里怎么写下标。

---

## 1. 三个概念：数组本体 / 指针变量 / 退化

### 1.1 数组本体（真的有一大块内存）

例如：

- `float score[7][4];`：一整块连续内存，里面有 28 个 `float`
- `char string[10][20];`：一整块连续内存，里面有 200 个 `char`

数组本体的特点：

- **不能整体赋值**：`score = ...`、`string = ...` 都不允许
- **`sizeof(score)` 是整块大小**（在同一个作用域里、没退化前）

### 1.2 指针变量（里面只放一个地址）

例如：

- `float *p;`
- `char *t;`
- `char *p[10];`（这是“指针数组”：10 个指针变量）

指针变量的特点：

- 可以赋值：`p = &score[0][0];`
- 可以 `p++`（指针移动）
- **`sizeof(p)` 是指针大小**（32 位是 4，64 位是 8）

### 1.3 退化（数组名在表达式里变成指针）

典型例子：

- `score`（数组名）在传参/比较/赋值等表达式里，常会变成“指向第 0 行的指针”
- `string[i]`（第 i 行数组名）会变成“指向该行第 0 个字符的指针”

这就是你经常看到的现象：

> “我明明写的是数组名，怎么到了函数里像指针一样用？”

因为它确实退化了。

---

## 2. 最重要的一张表：你写的形参到底是什么意思

下面用你题目里最常见的两个数组来解释：

- 二维浮点数组：`score[7][4]`
- 二维字符串数组：`string[10][20]`

### 2.1 `void f(float score[7][4])` / `void f(float score[][4])`

这看起来像二维数组形参，但**在参数位置它等价于**：

> `void f(float (*score)[4])`

意思：`score` 是“指向一行（4 个 float）的指针”，所以你能写：

- `score[i][j]`

在 `main` 里一般这样传：

- `f(score);`

### 2.2 `void f(float (*score)[4])`（行指针，最清晰）

这就是把上面的“真实类型”直接写出来。

- 函数内：`score[i][j]`
- `main` 里：`f(score);`

### 2.3 `void f(float *score)`（一维指针）

这表示：只给你一个“首元素地址”，**没有列数信息**。

结果就是：

- 函数内不能写 `score[i][j]`
- 必须自己把二维变一维：`score[i*4 + j]`（因为这题列数是 4）

`main` 里一般这样传：

- `f(&score[0][0]);` 或 `f((float*)score);`

> 你可以把它理解为：我把整块二维数组当成一条连续的一维数组交给你了。

### 2.4 `void f(char s[][20])` / `void f(char (*s)[20])`

用于字符串排序题的二维字符数组形参：

- `s` 是“指向一行（20 个 char）的指针”
- 函数内可以写 `s[i]`（第 i 个字符串）和 `s[i][j]`（某个字符）
- `main` 里传：`f(string);`

### 2.5 `void f(char *s)`（元素指针，用于把二维当一维）

用于你第 11 题那种“元素指针排序”：

- `s` 只是“第一个字符的地址”，没有“一行 20 个”的信息
- 第 i 个字符串的起始地址要自己算：`s + i*20`
- 第 i 行第 j 列字符：`*(s + i*20 + j)`

`main` 里传：

- `f(&string[0][0]);` 或 `f((char*)string);`

---

## 3. 你问的核心：我传进去的到底是什么？

给你一个“最不绕”的回答：

### 3.1 你在 `main` 里写 `f(score);` 时

- 你写的是数组名 `score`
- **传进去的是地址**，而且是“指向第 0 行的地址”，类型是 `float (*)[4]`
- 所以函数形参必须能接住它：`float (*score)[4]` 或写成 `float score[][4]`

### 3.2 你在 `main` 里写 `f(&score[0][0]);` 时

- 你传进去的是“第一个元素的地址”，类型是 `float*`
- 所以函数形参要写成 `float *score`
- 函数里要用 `i*4+j` 自己还原二维

### 3.3 你在 `main` 里写 `f(string);` 时

- 你传进去的是“指向第 0 行（20 个 char）的地址”，类型是 `char (*)[20]`
- 所以形参写 `char s[][20]` 或 `char (*s)[20]`

### 3.4 你在 `main` 里写 `f(string[i]);` 时

- `string[i]` 是第 i 行（一个 `char[20]`）
- 它会退化成 `char*`（指向该行第 0 个字符）
- 所以很多字符串函数都吃 `char*`：比如 `gets(string[i])`、`puts(string[i])`、`strcmp(string[i], string[j])`

---

## 4. 回到你这些字符串排序题：在主函数/函数内部该怎么做

下面只讲“怎么处理”的套路，你照着对照形参即可。

### 4.1 形参是 `char s[][20]` 或 `char (*s)[20]`（第 10 / 第 12 题）

主函数：

- `sort(string);`

函数内部：

- 第 i 个字符串：`s[i]`
- 比较：`strcmp(s[i], s[j]) > 0`（从小到大时，若 i 比 j 大就换）
- 交换内容（因为 `s[i]` 是数组，不能整体交换）：
  - `strcpy(t, s[i]);`
  - `strcpy(s[i], s[j]);`
  - `strcpy(s[j], t);`

### 4.2 形参是 `char *s`（第 11 题）

主函数：

- `sort(&string[0][0]);`（或 `sort((char*)string);`）

函数内部：

- 第 i 个字符串起始地址：`s + i*20`
- 比较：`strcmp(s + i*20, s + j*20) > 0`
- 交换内容：
  - `strcpy(t, s + i*20);`
  - `strcpy(s + i*20, s + j*20);`
  - `strcpy(s + j*20, t);`

### 4.3 指针数组 `char *p[10]` + `sort(char **p)`（第 13 题思路）

主函数（题目通常会留空让你把指针指向每行）：

- `p[i] = string[i];`
  - 这一步非常关键：让 `p` 里每个指针都指向一行字符串

然后：

- `sort(p);`

函数内部：

- 第 i 个字符串：`p[i]`（已经是 `char*`）
- 比较：`strcmp(p[i], p[j]) > 0`
- 交换指针（比 `strcpy` 更简单更快）：
  - 用题目给的临时指针 `w`：`w = p[i]; p[i] = p[j]; p[j] = w;`

---

## 5. 除了这些题，还有哪些常见情况？怎么理解？

### 5.1 一维数组传参：`int a[12]`

在参数位置等价于：

- `int *a`

所以：

- 主函数传：`sort(a);`
- 函数内用：`a[i]`

**注意坑**：在函数里 `sizeof(a)` 只是指针大小，不是数组总长度；长度通常要额外传进去（或题目固定）。

### 5.2 字符串参数：`char s[]` / `char *s`

在参数位置基本等价（都表示字符串首地址）：

- `void f(char s[])` 等价于 `void f(char *s)`

所以字符串题里常用指针递增：`s++`，或下标：`s[i]`（需要你自己有 `i`）。

### 5.3 二维数组参数“必须写列数”

你可以不写行数（因为行数可以变），但**列数必须写**：

- ✅ `void f(int a[][4])` / `void f(int (*a)[4])`
- ❌ `void f(int a[][])`（不允许）

原因：编译器算 `a[i][j]` 的地址时必须知道“一行多少个元素”。

### 5.4 `const`（只读保护，常见但不神秘）

如果函数不打算改字符串内容，经常会写：

- `int cmp(const char *a, const char *b);`

意思：我保证不通过这个指针去修改数据，只是读。

---

## 6. 你做填空题时的“10 秒判断法”（强烈推荐）

拿到一个 `sort/find` 之类函数，先只看形参：

1) 如果看到 `(*x)[20]` 或 `x[][20]`  
→ **行指针/二维数组形参**，函数里通常直接 `x[i]`，主函数传数组名 `string`

2) 如果看到 `char *x` 且题目是 `string[10][20]`  
→ **元素指针**，函数里用 `x + i*20`，主函数传 `&string[0][0]`

3) 如果看到 `char **p` 或 `char *p[]`，并且主函数有 `char *p[10]`  
→ **指针数组排序**，主函数先做 `p[i]=string[i]`，函数里交换指针

你只要按这个三分法，90% 的填空都不会再“传参看不懂”。

