# 编程题讲义：链表基础与多项式输出

> 目标：掌握“建立链表 → 遍历处理 → 按格式输出”的完整流程，避免野指针与内存泄漏。

## 1. 为什么用链表
链表适用于：
- 结点数量运行时才知道
- 需要频繁插入/删除
- 不想移动大量数组元素

在训练题中，链表常用来存“项”的集合（例如记录、系数-指数对等）。

## 2. 结点结构体（通用写法）
```c
typedef struct Node {
    int coef;          /* 系数 */
    int exp;           /* 指数 */
    struct Node *next;
} Node;
```
字段名按题目要求可调整，但结构大体一致。

## 3. 建表两种经典方式
### 3.1 尾插法（保持输入顺序）
```c
Node *head = NULL, *tail = NULL;
for (...) {
    Node *p = (Node*)malloc(sizeof(Node));
    /* 给 p->coef, p->exp 赋值 */
    p->next = NULL;
    if (head == NULL) head = tail = p;
    else { tail->next = p; tail = p; }
}
```

### 3.2 头插法（会反转顺序）
```c
Node *head = NULL;
for (...) {
    Node *p = (Node*)malloc(sizeof(Node));
    p->next = head;
    head = p;
}
```

## 4. 遍历与格式化输出（多项式输出的关键点）
多项式输出常见规则（不同题略有差异，但套路一致）：
- 指数为 0：只输出常数项
- 指数为 1：输出 `x`（不写 `x^1`）
- 系数为 1/-1：在某些规则下可省略 1（要看题意）
- 正负号与 `+` 的处理：第一项前通常不输出 `+`

建议写一个“输出单项”的函数，把规则集中管理，主循环只负责遍历。

## 5. 释放链表（基本功）
```c
while (head) {
    Node *tmp = head;
    head = head->next;
    free(tmp);
}
```

## 6. 自检清单
- `malloc` 后是否立刻初始化 `next`？
- 尾插时 `tail` 是否正确更新？
- 输出时第一项是否多了 `+`？
- 最后是否 `free` 了所有结点？

