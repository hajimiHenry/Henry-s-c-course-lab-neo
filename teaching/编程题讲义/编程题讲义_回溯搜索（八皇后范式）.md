# 编程题讲义：回溯搜索（八皇后范式）

> 目标：掌握“回溯 = 递归 + 试探 + 撤销”的通用模板，并理解如何剪枝让搜索可行。

## 1. 回溯问题的共同结构
这类题通常是：
- 要在多个位置放东西（或选东西）
- 每次放一个，必须满足约束
- 要输出某个解（或统计/枚举所有解）

## 2. 回溯三要素
1) **状态**：当前已经做了哪些选择（例如放了多少个、每个放在哪）。
2) **选择**：下一步可以尝试哪些候选。
3) **约束/合法性检查**：候选是否会与已有选择冲突。

## 3. 经典模板（必须会默写）
```c
void dfs(int row)
{
    if (row == N) {
        /* 得到一个完整解：记录/输出 */
        return;
    }
    for (int col = 0; col < N; col++) {
        if (ok(row, col)) {
            place(row, col);     /* 做选择 */
            dfs(row + 1);        /* 递归 */
            remove(row, col);    /* 撤销选择 */
        }
    }
}
```

## 4. 合法性检查与剪枝（效率关键）
以棋盘放置类为例，常见冲突有：
- 同列冲突
- 对角线冲突

剪枝思想：用数组记录“是否已被占用”，把 `ok()` 从 `O(N)` 降到 `O(1)`：
- `col[col]`：某列是否已用
- `diag1[row+col]`：主对角线
- `diag2[row-col+N-1]`：副对角线

## 5. “要输出第 b 个解”这种要求怎么做
常见做法有两类：
1) **预先生成所有解并排序/存储**：解数量有限时最简单。
2) **搜索过程中计数到第 b 个就停**：节省存储，但实现要仔细。

关键点：你要明确“解的顺序规则”是什么（按字典序/按数值大小/按搜索顺序），然后保证生成顺序一致。

## 6. 自检清单
- 递归终止条件是否正确？（`row==N`）
- `place/remove` 是否成对出现？撤销是否完整？
- 剪枝数组下标是否越界？（对角线下标常见坑）
- 解的输出顺序是否符合题意？

