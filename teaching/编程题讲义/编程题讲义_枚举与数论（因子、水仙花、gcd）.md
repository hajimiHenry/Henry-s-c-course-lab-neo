# 编程题讲义：枚举与数论（因子、水仙花、gcd）

> 目标：掌握三类高频数论题的通用做法：因子枚举、位数/数字拆分、gcd/lcm。

## 1. 因子枚举：从 1 到 n 会超时吗？
最朴素枚举因子是 `1..n`，当 `n` 大时可能慢。更稳的做法是枚举到 `sqrt(n)`：
```c
for (i = 1; i * i <= n; i++) {
    if (n % i == 0) {
        /* i 是因子，n/i 也是因子 */
    }
}
```
这样复杂度从 `O(n)` 变成 `O(sqrt(n))`。

### 1.1 完数（perfect number）的思想
完数的定义通常和“真因子和”有关（不包含自身）。做法：
1) 枚举因子到 `sqrt(n)`
2) 累加 `i` 和 `n/i`（注意去重：`i*i == n` 时只加一次）
3) 最后判断是否满足条件

注意：多数规则不把 `n` 本身算进因子和。

## 2. 数字拆分：取末位与去末位
对一个正整数 `x`：
- 末位：`x % 10`
- 去末位：`x /= 10`

### 2.1 水仙花数/自幂数类题的通用套路
核心是“按位拆分 → 做幂运算 → 求和 → 与原数比较”。

步骤模板：
1) 先得到位数 `k`（可以用循环计数或转字符串）
2) 再把每一位取出来，累加 `digit^k`
3) 比较是否等于原数

幂运算可以用 `pow`，也可以自己写整数幂（更稳，避免浮点误差）：
```c
int ipow(int a, int k) {
    int r = 1;
    while (k--) r *= a;
    return r;
}
```

## 3. gcd 与 lcm：欧几里得算法
最大公因数模板：
```c
int gcd(int m, int n) {
    int r;
    while (n != 0) {
        r = m % n;
        m = n;
        n = r;
    }
    return m;
}
```

最小公倍数：
```c
long long lcm = (long long)m0 / gcd(m0, n0) * n0;
```
用 `m0 / gcd * n0` 可减少溢出风险。

## 4. 自检清单
- 因子枚举是否漏了配对因子 `n/i`？
- `i*i == n` 的平方根因子是否重复加了？
- 数字拆分循环是否会在 `x==0` 时正确结束？
- gcd 循环更新顺序是否正确？（`r`、`m`、`n`）

