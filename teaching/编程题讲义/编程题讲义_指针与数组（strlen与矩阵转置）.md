# 编程题讲义：指针与数组（`strlen` 与矩阵转置）

> 目标：把“用指针实现”真正写顺：指针移动、解引用、边界条件不出错。

## 1. 指针版 `strlen`：从首地址走到 `\0`
字符串以 `\0` 结尾，所以长度就是 `\0` 之前的字符个数。

### 1.1 最直观写法
```c
int my_strlen(const char *p)
{
    int len = 0;
    while (*p != '\0') {
        len++;
        p++;
    }
    return len;
}
```

### 1.2 指针差写法（进阶但常见）
```c
int my_strlen(const char *s)
{
    const char *p = s;
    while (*p) p++;
    return (int)(p - s);
}
```

填空题常考：`while (*p)`、`p++`、`p - s`。

## 2. 矩阵转置：下标版与指针版的关系
矩阵转置的定义：输出矩阵 `B`，使得：
```
B[j][i] = A[i][j]
```

### 2.1 下标版思路（先理解这个）
```c
for (i = 0; i < r; i++)
    for (j = 0; j < c; j++)
        B[j][i] = A[i][j];
```

### 2.2 指针版怎么理解
二维数组在内存中是连续的“按行排列”。指针版本质仍然是找到正确地址并赋值。

如果形参写成：
```c
void trans(int (*a)[C], int (*b)[R])
```
那么 `a[i][j]` 依然可以用下标访问；“用指针实现”更多是在考你形参类型和传参方式是否正确。

## 3. 二维数组传参的关键：列数必须写出来
例如 `int a[3][4]` 传参时，形参常写：
- `int a[][4]`
- `int (*a)[4]`

## 4. 自检清单
- `strlen` 是否会把 `\0` 也计入长度？（不应该）
- 指针移动是否会越过 `\0` 后继续访问？（不应该）
- 转置时下标是否写反？（应当是 `B[j][i] = A[i][j]`）
- 二维数组形参的列数是否与实参一致？

