# 14_结构体数组排序与比较规则codex

## 题目目标（你现有写法的“补全路线”）

你现在已经做到了：

- 用结构体数组保存每个选手的信息（编号 + 4 个分数）。
- 能求出“去掉最低分后的总分”（或至少已经接近）。

题目在此基础上还需要你补上两件事：

1. **把每个人的总分算准确**（尤其注意：最低分是哪一个、总分要初始化、输入要读满 4 个分数）。
2. **按规则排序输出**  
   - 先按 `总分` 从高到低  
   - 若 `总分相同`，按 `最低分` 从小到大（最低分更小的排前面）  
   - 若还相同，为了不乱序：保持输入顺序（稳定排序）

下面给你“最贴近你原有结构体数组写法”的实现思路。

---

## 第 1 步：结构体里补齐“排序需要的字段”

你原来结构体里只有 `name/arr`，排序时你还需要：

- `sum3`：去最低分后的总分（排序的主关键字）
- `minScore`：四个分数中的最低分（总分相同时的次关键字）
- `idx`：输入顺序（总分、最低分都相同的时候保持稳定）

示例（照着加字段即可）：

```c
typedef struct {
    char name[10];    // 编号长度<10，开 10（含 '\0'）
    int arr[4];       // 4 个评委分数
    int sum3;         // 去最低分后的总分
    int minScore;     // 原始最低分
    int idx;          // 输入顺序（0,1,2,...）
} player;
```

> 为什么建议 `name[10]`：题目给“长度小于 10”，用 `%9s` 读入最安全。

---

## 第 2 步：输入要“读满 4 个分数”（并且写对 `&`）

### 2.1 编号（字符数组）不加 `&`

`name` 是数组：`scanf("%9s", x[i].name);` **不加 `&`**。

### 2.2 分数（int）必须加 `&`

`arr[k]` 是一个 `int` 变量：读入要传地址 `&x[i].arr[k]`。

正确读法示例：

```c
scanf("%9s%d%d%d%d",
      x[i].name,
      &x[i].arr[0], &x[i].arr[1], &x[i].arr[2], &x[i].arr[3]);
```

---

## 第 3 步：一次循环里把 `minScore` 和 `sum3` 算出来

最稳的写法是：

1. 先把 `minScore` 设成第 0 个分数
2. 用一个 `sum` 把 4 个分数全部加起来（**注意 sum 要初始化为 0 或 arr[0]**）
3. `sum3 = sum - minScore`

示例（放在读入之后）：

```c
x[i].idx = i;

int minScore = x[i].arr[0];
int sum = x[i].arr[0];
for (int k = 1; k < 4; k++) {
    if (x[i].arr[k] < minScore) minScore = x[i].arr[k];
    sum += x[i].arr[k];
}
x[i].minScore = minScore;
x[i].sum3 = sum - minScore;
```

> 你原先那种“找到最低分下标，再跳过它求和”也可以，但更容易写错（常见错：`if (q=indexmin)` 这种把 `==` 写成 `=`）。上面这种“总和减最低分”更短更稳。

---

## 第 4 步：排序（建议先用冒泡/选择，最直观）

### 4.1 什么时候要交换（比较规则）

给相邻两个人 `A = x[j]`、`B = x[j+1]`：

- 如果 `A.sum3 < B.sum3`：A 应该排后面 → **交换**
- 否则如果 `A.sum3 == B.sum3` 且 `A.minScore > B.minScore`：A 的最低分更大，应该排后面 → **交换**
- 否则如果还相同，为稳定：`A.idx > B.idx` 才交换（一般不会发生，因为 idx 原本递增，但写上逻辑更完整）

### 4.2 冒泡排序模板（直接可用）

```c
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - 1 - i; j++) {
        int needSwap = 0;
        if (x[j].sum3 < x[j + 1].sum3) needSwap = 1;
        else if (x[j].sum3 == x[j + 1].sum3 && x[j].minScore > x[j + 1].minScore) needSwap = 1;
        else if (x[j].sum3 == x[j + 1].sum3 && x[j].minScore == x[j + 1].minScore && x[j].idx > x[j + 1].idx) needSwap = 1;

        if (needSwap) {
            player tmp = x[j];
            x[j] = x[j + 1];
            x[j + 1] = tmp;
        }
    }
}
```

> 关键点：**交换要交换“整个人”**（结构体整体换），不要只换 `sum` 或只换 `name`，不然数据会错位。

---

## 第 5 步：按格式输出

题目要求每行：

```c
printf("%10s%6d\n", x[i].name, x[i].sum3);
```

注意 `%10s` 是右对齐宽度 10，`%6d` 是宽度 6。

---

## 常见坑清单（你之前代码里出现过的那类）

1. `scanf` 里 `%d` 忘写 `&`：`scanf("%d", &a);`
2. 数组读入写错：  
   - `scanf("%s", name);`（对）  
   - `scanf("%s", &name);`（错，name 是数组时）
3. 判断写成赋值：`if (a = 1)`（错）应为 `if (a == 1)`
4. `sum` 不初始化：`int sum; sum += ...;`（错）应 `int sum = 0;`
5. 只换了 `sum` 没换 `name`：排序后会“编号和分数对不上”

---

## 如果你用的是 VS（MSVC）的提醒

你原来写的 `player x[n];` 属于 **变长数组（VLA）**，MSVC 默认不支持。题目 `N<15` 的情况下最省事的做法是直接：

```c
player x[15];
```

这样任何 Windows/VS 环境都能编译通过。

---

## 你可以对照的完整示范

对应的完整示范代码我放在：

- `Henry-s-c-course-lab-neo/final-review/14_codex.c`

你可以用这份讲义对照着，把自己的 `14.c` 一点点补齐（先算对，再排序）。

