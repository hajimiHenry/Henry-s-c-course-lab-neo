# 25-13-6 二维数组的“指针写法”怎么读：`*(*(a+i)+j)` 与 `pmax`

对应代码：`Henry-s-c-course-lab-neo/25-13/25-13-6codex.c`

你卡住的这一句是：

```c
if (*(*(a + i) + j) > *pmax) {
    pmax = *(a + i) + j;
}
```

本讲义专门讲清楚：`a` 的类型是什么、`*(a+i)`/`*(a+i)+j`/`*(*(a+i)+j)` 每一步分别代表什么，以及为什么它等价于 `a[i][j]`。

---

## 1. 先看参数类型：`int (*a)[5]` 是什么？

在函数里写的是：

```c
void adjust_codex(int (*a)[5]);
```

读法：`a` 是一个**指针**，指向“长度为 5 的 int 数组”（也就是指向**一整行**）。

所以你可以把它想成：

- `a` 指向第 0 行
- `a + 1` 指向第 1 行
- `a + i` 指向第 i 行

这也是为什么它不是 `int **`：二维数组在内存里是“整块连续的 25 个 int”，不是“指针的指针”那种结构。

---

## 2. 二维数组在内存里的样子（关键直觉）

`int a[5][5];` 可以理解成 5 行，每行 5 个 int，整体连续：

```
第0行: a[0][0] a[0][1] a[0][2] a[0][3] a[0][4]
第1行: a[1][0] a[1][1] a[1][2] a[1][3] a[1][4]
...
第4行: a[4][0] a[4][1] a[4][2] a[4][3] a[4][4]
```

“行指针”`a` 走一步（`a+1`），跨过的是一整行（5 个 int）。

---

## 3. 把 `*(*(a+i)+j)` 拆开，一步一步读

从里往外读（建议你以后都这么读）：

### 第一步：`a + i`

- 类型：`int (*)[5]`
- 含义：指向第 `i` 行的指针

### 第二步：`*(a + i)`

- 类型：`int [5]`（“第 i 行”这个数组本身）
- 含义：第 `i` 行（一个含 5 个 int 的数组）

### 第三步：`*(a + i) + j`

这里发生了一个非常重要的“数组退化”：

- `*(a + i)` 是数组，放到表达式里会**自动转换**成指向首元素的指针：`&a[i][0]`
- 所以 `*(a + i) + j` 的类型是 `int *`
- 含义：指向第 `i` 行第 `j` 列元素的地址，也就是 `&a[i][j]`

### 第四步：`*(*(a + i) + j)`

- 类型：`int`
- 含义：把上一步得到的地址解引用，拿到那个格子的值，也就是 `a[i][j]`

总结等价关系（背下来很有用）：

```c
a[i][j]        == *(*(a + i) + j)
&a[i][j]       == *(a + i) + j
```

---

## 4. 回到你选中的 if：它其实就是在比较 `a[i][j]` 和“当前最大值”

原句：

```c
if (*(*(a + i) + j) > *pmax) {
```

等价更直观的写法是：

```c
if (a[i][j] > *pmax) {
```

这里的 `pmax` 是一个 `int *`，它“指向当前找到的最大值所在的那个格子”。

---

## 5. `pmax` 是怎么被“操作/更新”的？

在代码里：

```c
int *pmax = &a[0][0];
```

意思是：先假设最大值在左上角，让 `pmax` 指向它。

当扫描到某个格子更大时，就把 `pmax` 改成指向那个格子的地址：

```c
pmax = *(a + i) + j;   /* 等价于：pmax = &a[i][j]; */
```

所以这段完整逻辑等价于“找最大值位置”：

```c
int *pmax = &a[0][0];
for (i = 0; i < 5; i++) {
    for (j = 0; j < 5; j++) {
        if (a[i][j] > *pmax) {
            pmax = &a[i][j];
        }
    }
}
```

---

## 6. 你觉得“语法绕”的根源：运算符优先级 + 括号

`*(*(a + i) + j)` 这个写法其实是在强行把“数组下标”翻译成“指针运算”：

- `a[i]` 其实等价于 `*(a + i)`
- `a[i][j]` 其实等价于 `*(*(a + i) + j)`

括号的作用是告诉你：“先算地址，再解引用”：

- 先得到地址：`(*(a + i) + j)`
- 再取值：`* ( ... )`

---

## 7. 自测（推荐你做完再回去看代码）

1. 把下面三句分别改写成“指针版本”：
   - `a[2][3]`
   - `&a[4][0]`
   - `a[i][0]`
2. 反过来，把下面三句改写成“下标版本”：
   - `*(*(a + 1) + 4)`
   - `*(a + i) + j`
   - `*pmax`

如果你愿意，我也可以把 `25-13-6codex.c` 里所有 `*(*(a+i)+j)` 都替换成更易读的 `a[i][j]`（逻辑不变），保留“指针版”当对照练习。  
