# 5_数组传参与退化codex

目标：把“一维/二维数组在函数里怎么传、怎么写形参、为什么会退化”系统讲清楚，并能落到写代码上不再迷糊。

---

## 1. 先记住一句总规则：数组传参 ≈ 传地址
在 C 里，**数组作为函数参数时不会被整体拷贝**，传进去的本质是“指向数组首元素的地址”（指针）。

这件事通常靠“数组名的退化”自动完成：
- 一维数组名 `s` 在表达式里常常会退化为 `&s[0]`
- 二维数组名 `a` 在表达式里常常会退化为 `&a[0]`（注意：是“第 0 行”的地址）

---

## 2. 什么是“退化（decay）”
**退化**：数组名出现在大多数表达式中，会自动变成指向首元素的指针。

### 2.1 一维数组的退化
```c
char s[12];
```
- `s` 的“本体类型”是 `char[12]`
- 在表达式/传参时：`s` → 退化为 `&s[0]`，类型变成 `char *`

所以这两句等价：
```c
f(s);      // 传首元素地址
f(&s[0]);  // 传首元素地址
```

### 2.2 二维数组的退化（最容易混淆）
```c
char a[n][13];
```
把它读成：**a 是“n 行”，每行是“13 个 char 的数组”**。

- `a` 的“本体类型”是 `char[n][13]`
- 在表达式/传参时：`a` → 退化为 `&a[0]`
  - 类型是 `char (*)[13]`（指向“一行 char[13]”的指针）

关键点：二维数组退化后不是 `char*`，而是“指向一行的指针”。因为 `a+1` 必须能跳到下一行（跨过 13 个 char）。

---

## 3. 退化的例外（什么时候“不退化”）
数组名不总是退化，常见例外有：

### 3.1 `sizeof(数组名)`
```c
char s[12];
sizeof(s)   // = 12（整个数组大小）
```
但如果你把它作为函数形参 `char s[]`，那形参已经是“指针”了：
```c
void g(char s[]) { sizeof(s); } // 这里是指针大小，不是 12
```

### 3.2 取整个数组地址 `&数组名`
```c
char s[12];
&s     // 类型是 char (*)[12]，指向“整个数组”的指针
```
它和 `s`（退化后是 `char*`）类型不同。

**一句话**：`s` 通常表示“首元素地址”，`&s` 表示“整个数组的地址”。

---

## 4. 一维数组在函数中怎么写（形参写法大全）

### 4.1 最推荐：写成指针 + 长度
```c
int sum_digits(const char *s, int len);
```
调用：
```c
sum_digits(s, 11);
```

### 4.2 也可以写成“数组形参”（本质仍是指针）
下面三种形参写法等价（都表示 `int *a`）：
```c
void f(int a[], int n);
void f(int a[100], int n);
void f(int *a, int n);
```
注意：`a[100]` 只是“提示”，不限制实际长度。

### 4.3 什么时候用 `const`
如果函数只读不改参数，推荐加 `const`：
```c
int sum_digits(const char *s, int len);
```
好处：防止你在函数里误改内容，编译器会拦。

---

## 5. 二维数组在函数中怎么写（必须知道“每行多宽”）

### 5.1 推荐写法：固定第二维
如果你每行长度固定（例如手机号一行 13 个 char）：
```c
int sum_row(const char a[][13], int row)
{
    int total = 0;
    for (int i = 0; i < 11; i++)
        if (a[row][i] >= '0' && a[row][i] <= '9') total += a[row][i] - '0';
    return total;
}
```
调用：
```c
int s = sum_row(a, p);
```

形参 `const char a[][13]` 等价于 `const char (*a)[13]`。

### 5.2 指针形式（和上面是同一种意思）
```c
int sum_row(const char (*a)[13], int row);
```
这就是“指向一行（13 个 char）的指针”。

### 5.3 用 VLA（可变长度数组）写法（了解即可）
当第二维不是常量、由参数决定时：
```c
int sum_row(int n, int m, const char a[][m], int row);
```
这要求编译器支持 C99/C11 的 VLA（有些环境可能限制）。

---

## 6. 你这题（手机号）的正确“传法”对照
假设：
```c
char arr[n][13];
```

### 6.1 只对“某一行字符串”求和（最自然）
```c
int sum_one(const char *s);
```
调用：
```c
sum_one(arr[p]);      // arr[p] 会退化成 char*
// 等价：sum_one(&arr[p][0]);
```

### 6.2 想把“整个二维数组”传进去，再指定哪一行
```c
int sum_at(const char (*a)[13], int row);
```
调用：
```c
sum_at(arr, p);       // arr 退化成 char (*)[13]
```

### 6.3 为什么 `sum(*arr)` 不对（你之前卡住的点）
`arr` 退化后是 `&arr[0]`，所以：
- `*arr` 等价于 `arr[0]`（永远第 0 行）
- `sum(*arr)` 等价于 `sum(arr[0])`

你在循环里想求第 `p` 行，就必须是：
- `sum(arr[p])`

---

## 7. 一张表帮你记住常用表达式的“含义”

### 7.1 一维 `char s[12]`
- `s`：退化后 `&s[0]`（首元素地址）
- `&s[0]`：首元素地址（同上）
- `&s`：整个数组地址（类型不同）
- `s[i]`：第 i 个字符

### 7.2 二维 `char a[n][13]`
- `a`：退化后 `&a[0]`（第 0 行地址，类型 `char (*)[13]`）
- `a[p]`：第 p 行（再退化为 `&a[p][0]`，类型 `char*`）
- `a[p][i]`：第 p 行第 i 列字符
- `*a`：等价 `a[0]`（第 0 行）

---

## 8. 写代码时的“实用建议”（避免最常见坑）
1. 你要处理“一行字符串”时，形参优先写 `const char *s`，调用用 `arr[p]`。
2. 你要处理“二维表格”时，形参必须写清第二维：`(*a)[13]` 或 `a[][13]`。
3. 别用 `%d` 读手机号；用 `%11s`，并给数组留 `'\0'` 的位置。
4. 读单个字符 `%c` 时记得写 `" %c"` 跳过空白。

如果你愿意，把你 `5.c` 里 `arr` 的定义（到底 `[12]` 还是 `[13]`）确定下来后，我可以按你选的版本，把“求和函数 + 调用点”给你写成最标准、最不绕的那一套。  

