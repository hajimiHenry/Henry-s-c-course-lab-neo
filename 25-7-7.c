// 任务：把输入的分数 a/b 约成“最简分式”，并以 a/b 形式输出。
// 说明：
// 1) “最简分式”就是分子与分母没有大于 1 的公因数。
// 2) 我们先求出 a 与 b 的“最大公约数”（greatest common divisor，缩写 gcd），
//    然后让分子、分母同时除以 gcd，一步到位得到最简分式。
// 3) 本题只按 a/b 的样式输出，不需要化成带分数。
//
// 这里使用“辗转相除法（欧几里得算法）”求 gcd，核心性质：
//    gcd(a, b) = gcd(b, a % b)
// 直观理解：若 r = a % b（a 被 b 除的余数），那么 a = q*b + r。
// 对能同时整除 a 和 b 的数 d，也必定能整除 r；反过来同时整除 b 和 r 的 d 也能整除 a。
// 所以 (a, b) 与 (b, r) 的公约数集合相同，最大公约数也相同。

#include <stdio.h>

// 函数：gcd
// 作用：计算并返回两个整数 a、b 的最大公约数。
// 做法：使用辗转相除法；为安全起见，先把负数取绝对值。
// 返回：非负整数（当 a=b=0 的极端情况，返回 1 以避免后续除 0）。
long long gcd(long long a, long long b) {
    if (a < 0) a = -a;
    if (b < 0) b = -b;
    // 极端防御：如果 a 和 b 都是 0，返回 1，避免后续出现除以 0 的错误
    if (a == 0 && b == 0) return 1;
    while (b != 0) {
        // 每一步把 (a, b) 变成 (b, a%b)，余数严格变小，最终会到 0
        long long r = a % b; // 余数 r = a - q*b
        a = b;
        b = r;
    }
    // 循环结束时 b==0，此时 a 就是最后一个非 0 的数，也就是 gcd
    // 额外处理 a==0 的极端情况（与前面的防御一致）
    return a == 0 ? 1 : a;
}

int main(void) {
    long long a, b; // a: 分子  b: 分母

    // 输入格式形如 12/34
    // 读取“分子/分母”这种格式（例如 12/34）。
    // 注意：不打印“请输入”等提示文字，保持题目要求的纯输入输出。
    if (scanf("%lld/%lld", &a, &b) != 2) return 0; // 读取失败直接结束

    // 统一把分母变为正，负号放到分子上（更规范）
    // 规范化：若分母为负，把负号挪到分子上，使分母保持为正数，
    // 这样输出更规范（例如 -1/3，而不是 1/-3）。
    if (b < 0) { a = -a; b = -b; }

    // 分子为 0，最简就是 0/1
    // 特判：分子为 0，任何非 0 分母下最简就是 0/1。
    if (a == 0) { printf("0/1\n"); return 0; }

    // 第 1 步：求出 a 和 b 的最大公约数 g
    long long g = gcd(a, b);
    // 第 2 步：把分子与分母都除以 g，得到最简分式
    a /= g;
    b /= g;

    // 第 3 步：按“分子/分母”的格式输出结果
    printf("%lld/%lld\n", a, b);
    return 0;
}
