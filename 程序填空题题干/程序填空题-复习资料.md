# 程序填空复习资料（详细版）

本资料不针对某一道题，而是把常见“程序填空”背后的知识点讲透：你只要能看懂每个模块的原理、模板与自检清单，就能在不同变形里快速定位空缺。

---

## 0. 程序填空的通用解题方法（先学这个）

很多同学做填空题不是“不会算法”，而是卡在：
- 语法结构没补全（括号、分号、参数、类型不匹配）
- 数据流没理清（变量什么时候被更新、数组下标对应什么含义）
- C 语言“数组退化/指针”概念不牢（尤其是二维数组传参）

建议按下面顺序做：

### 0.1 先补“能编译”的结构
优先补齐：分号 `;`、右括号 `)`、右花括号 `}`、`for/if` 的括号、函数调用的参数个数。结构不全，后面逻辑再对也没用。

### 0.2 再补“类型正确”的表达式
看每个空缺前后：
- 如果在 `scanf` 里，通常需要“地址”（多数情况要 `&变量`；数组名本身通常不加 `&`）。
- 如果在 `printf` 里，通常需要“值”（`*p` 还是 `a[i]` 还是 `score[i][j]`）。
- 如果在 `if(...)` 里，空缺通常是比较表达式或逻辑组合。

### 0.3 最后补“逻辑正确”的更新语句
填空最常见的“逻辑点”是：
- 循环变量更新（`i++`/`j++`）
- 最大值/最小值更新（`max = ...` 同时更新位置）
- 交换（`t = a; a = b; b = t;`）
- 指针返回结果（`*hang = i; *lie = j;`）

### 0.4 自检清单（做完必须过一遍）
- `scanf` 的返回值、格式串和参数数量是否一致？
- `scanf` 的参数是否该加 `&`？（尤其是数组元素）
- 循环边界是否会越界？（`j+1` 会不会访问到最后一位之外）
- 字符串是否保证以 `\0` 结束？
- 传给函数的参数类型是否匹配形参？（二维数组最容易错）

---

## 1. 循环、条件与“坐标思想”（图形/表格输出通用）

### 1.1 双层循环的含义
当你写：
- 外层 `for (i = 0; i < n; i++)`：控制“第 i 行”
- 内层 `for (j = 0; j < n; j++)`：控制“第 j 列”

这时 `(i, j)` 就是一个坐标点。题目让你输出某种图案/表格，本质就是定义：哪些坐标输出字符，哪些输出空格。

### 1.2 常用坐标条件（背下来，基本就稳了）
- 主对角线：`i == j`
- 副对角线：`i + j == n - 1`
- 第一列/最后一列：`j == 0 || j == n - 1`
- 第一行/最后一行：`i == 0 || i == n - 1`
- 上三角/下三角：`i < j`、`i > j`
- 距离边界：例如“离左边 k 格”：`j == k`

### 1.3 逻辑运算优先级：必须会加括号
C 语言里 `&&` 的优先级高于 `||`。也就是说：
- `A || B && C` 等价于 `A || (B && C)`

如果你想表达 `(A || B) && C`，必须写括号，否则图案会错。

### 1.4 输出与换行
常见错误：忘记换行。规范写法：每输出完一行，补一个换行。

通用模板：
```c
for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
        if (/* 坐标条件 */) putchar('*');
        else putchar(' ');
    }
    putchar('\n');
}
```

---

## 2. 最大公因数 gcd 与最小公倍数 lcm（欧几里得算法讲透）

### 2.1 为什么“取余 + 交换”能求 gcd？
核心事实：`gcd(m, n) == gcd(n, m % n)`。
直观理解：
- 能整除 `m` 和 `n` 的数，也一定能整除 `m - k*n`。
- `m % n` 就是 `m - (m/n)*n`，它和 `m`、`n` 的公因数集合不变。

所以不断把问题变小（`m % n < n`），最终余数变 0，gcd 就出来了。

### 2.2 代码模板（必须熟练到能默写）
```c
int gcd(int m, int n) {
    int r;
    while (n != 0) {
        r = m % n;
        m = n;
        n = r;
    }
    return m;
}
```

### 2.3 lcm 的公式与为什么要保存原值
`lcm(m, n) = m * n / gcd(m, n)`。
但注意：求 gcd 的过程中 `m`、`n` 会被改写，所以需要保存 `m0`、`n0`。

### 2.4 常见坑
- 溢出：`m0 * n0` 可能超出 `int`，保守做法用 `long long`。
- 输入格式：有些题 `scanf("%d,%d", &m, &n)` 带逗号，少一个逗号就读不进。

---

## 3. 数组、下标与“最大值定位”（二维数组最常考）

### 3.1 二维数组到底是什么？
`float score[7][4]` 可以理解为“7 行，每行 4 个 float”。内存是连续的：
- `score[i]` 表示第 i 行（类型是“含 4 个 float 的数组”）
- `score[i][j]` 才是具体元素

### 3.2 最大值定位的通用模板（值 + 位置同时更新）
必须记住：更新最大值时，位置也要同步更新。

```c
max = score[0][0];
maxhang = 0;
maxlie = 0;
for (i = 0; i < 7; i++) {
    for (j = 0; j < 4; j++) {
        if (score[i][j] > max) {
            max = score[i][j];
            maxhang = i;
            maxlie = j;
        }
    }
}
```

### 3.3 输出从 1 开始还是 0 开始？
程序内部下标一定是从 0 开始。
- 如果输出要求从 1 开始编号：输出时 `+1`。
- 如果输出要求从 0 开始编号：直接输出。

填空题常把坑埋在输出那一行。

### 3.4 `scanf` 读二维数组时的“&”
- 读一个元素：要地址 `&score[i][j]`
- 读一整行数组：一般不会这么写在基础题里

如果你看到 `scanf("%d", ____ );`，多数时候空缺是 `&score[i][j]` 或 `&a[i]`。

---

## 4. 二维数组传参、指针与函数返回多个值（最容易混）

这一块是程序填空的高频重灾区：**你必须能看懂“形参类型”和“实参类型”是否一致。**

### 4.1 数组传参会发生什么？（数组退化）
把数组名传给函数时，数组名会“退化”为指向首元素的指针：
- 一维：`int a[12]` 传入后看作 `int *a`
- 二维：`float score[7][4]` 传入后看作 `float (*)[4]`（指向“含 4 个 float 的数组”的指针）

所以二维数组的形参常见写法是：
```c
void f(float (*p)[4]) { /* ... */ }
/* 或 */
void f(float p[][4]) { /* ... */ }
```

### 4.2 为什么不能写成 `float **p`？
`float **p` 表示“指向 float 指针的指针”，对应的是“指针数组/动态二维数组”的那套结构，不等价于连续内存的 `float score[7][4]`。

判断口诀：
- 连续二维数组：形参用 `(*p)[列数]`
- 指针数组（每行一个指针）：形参才可能用 `float **p` 或 `float *p[]`

### 4.3 用指针把行列“传回去”
当函数要返回两个结果（例如行列位置），就用指针参数：
```c
void find(float (*p)[4], int *hang, int *lie) {
    int i, j;
    float max = p[0][0];
    *hang = 0;
    *lie = 0;
    for (i = 0; i < 7; i++) {
        for (j = 0; j < 4; j++) {
            if (p[i][j] > max) {
                max = p[i][j];
                *hang = i;
                *lie = j;
            }
        }
    }
}
```

填空时高频空缺：
- `*hang = 0; *lie = 0;`
- `max = p[0][0];`
- 更新时 `*hang = i; *lie = j;`

---

## 5. C 字符串：本质、输入方式与三大函数（比较/复制/连接）

### 5.1 C 字符串的本质
C 字符串是 `char` 数组，**以 `\0` 结尾**。
- `"abc"` 在内存里是：`'a' 'b' 'c' '\0'`

所以任何字符串操作的核心都绕不开：
- 从开头走到 `\0`
- 必须保证最后有 `\0`

### 5.2 输入：`gets`、`scanf("%s")`、`fgets`
程序填空里可能出现 `gets`（虽然不安全），你需要知道它的行为：
- `gets(s)` 读入一整行（不含换行），直到遇到换行结束，然后自动补 `\0`

`scanf("%s", s)` 的特点：
- 遇到空白（空格/换行/制表）就停止

更推荐但题里不一定给的：
- `fgets(s, sizeof s, stdin)` 会把换行也读进来（若有空间），需要自己去掉 `\n`

填空题常见坑：
- `gets(____);` 空缺通常是某个字符串数组元素，如 `string[i]`
- `puts(____);` 空缺通常也是 `string[i]` 或 `p[i]`

### 5.3 `strcmp`：为什么能比较字典序？
`strcmp(a, b)` 从头比较：
- 遇到不同字符就返回差值
- 都到 `\0` 仍相同就返回 0

因此：
- `strcmp(a, b) > 0` 表示 `a` 在字典序上更大
- `strcmp(a, b) < 0` 表示 `a` 更小

### 5.4 `strcpy` / `strcat` 的“终止符”规律
无论复制还是连接，最后都必须写 `\0`。
- `strcpy` 复制包含 `\0`
- `strcat` 会把目标串末尾的 `\0` 覆盖掉，然后在新末尾再写一个 `\0`

自己写循环时，最常漏的就是最后那个 `\0`。

---

## 6. 排序：为什么这样写？交换到底交换什么？

排序题不重要的是“用冒泡还是选择”，重要的是：
- 比较条件写对（整数用 `>`，字符串用 `strcmp`）
- 交换对象写对（交换元素还是交换指针）
- 循环边界写对（尤其 `j+1` 是否越界）

### 6.1 整数排序（冒泡）的边界为什么是 `n-1-i`？
冒泡每一趟会把最大值“冒”到末尾，所以末尾已经排好不需要再比较。
若比较 `a[j]` 与 `a[j+1]`，那么 `j` 最大只能到 `n-2`，否则 `j+1` 越界。

模板：
```c
for (i = 0; i < n - 1; i++)
    for (j = 0; j < n - 1 - i; j++)
        if (a[j] > a[j+1]) {
            t = a[j];
            a[j] = a[j+1];
            a[j+1] = t;
        }
```

### 6.2 字符串排序：交换“内容”还是交换“指针”？
情况 A：二维数组 `char string[10][20]`
- 每个元素是一段固定长度的字符数组
- 交换时常用临时数组 `t[20]` 做 `strcpy`

情况 B：指针数组 `char *p[10]`
- 每个元素是一个指针
- 排序时可以只交换指针（更快），但前提是每个 `p[i]` 都指向有效字符串

填空题里经常考：
- `strcmp( ... )` 的参数到底是 `string[i]` 还是 `p[i]`
- 交换时到底用 `strcpy` 还是换指针

### 6.3 常见比较条件写法
- 递增（从小到大）：若 `a` 大于 `b` 就交换
- 字符串递增：若 `strcmp(s[i], s[j]) > 0` 就交换

---

## 7. “按分隔符统计单词长度”：状态机思想

这类题背后的核心不是字符串函数，而是“状态机”：
- 状态 0：当前不在单词里
- 状态 1：当前在单词里

读到字符时：
- 如果是字母/数字（非分隔符）：进入状态 1，并 `count++`
- 如果是分隔符：若之前在状态 1，则输出 `count`，清零并回到状态 0

关键细节：
- 连续分隔符：不能重复输出 0
- 结尾分隔符（如句号）前的最后一个单词：必须能输出

如果填空题里出现 `word` 或 `flag` 之类变量，十有八九就是这个思想。

---

## 8. I/O 与格式串：填空题里最容易丢分的细节

### 8.1 `scanf` 的参数为什么常要加 `&`？
`scanf` 要把读到的数据写进变量，所以需要“地址”。
- `int x; scanf("%d", &x);`
- `int a[12]; scanf("%d", &a[i]);`

例外：
- 字符数组名 `char s[20]; scanf("%s", s);`（数组名已是地址）

### 8.2 `%d`、`%f`、`%lf`、`%.2f`
- `int` 用 `%d`
- `float` 读入用 `%f`
- `double` 读入用 `%lf`
- 打印保留两位小数用 `%.2f`

很多填空题把“变量类型”和“格式串”混在一起考。

---

## 9. 最后总结：你真正要掌握的“底层能力”

1) 能把程序补到可编译（结构与类型正确）。
2) 能看懂数组/指针在内存中的对应关系（尤其二维数组传参）。
3) 能写出 3 个模板：最大值定位、欧几里得算法、冒泡/选择排序。
4) 能用 `\0` 的视角理解所有字符串题。

只要这四条过关，程序填空题的变形再多也不怕。
